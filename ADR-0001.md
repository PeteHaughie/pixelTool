# ADR 0001 — Project file / storage format options

Date: 2026-01-30

Status: proposed

Context
- The project stores multi-frame, multi-layer pixel artwork plus palette and metadata. We need a simple, lossless, extensible project file format that is easy to read/write from Processing/Java, is previewable outside the app, and preserves palette/metadata exactly.

Decision Drivers
- Lossless storage for pixel data (no lossy compression altering colors).
- Ability to view frames and previews externally (image viewers).
- Single-file distribution preferred by users but extensibility and tooling friendliness important.
- Avoid fragile or highly custom encodings unless clear benefits.
- Implementation effort: should be reasonably simple to implement in Processing (Java) without heavy native libraries.

Options Considered

1) ZIP container (recommended)
- Layout: a single ZIP file containing a `manifest.json` (schema + metadata), `frames/frame_000.png` (one PNG per frame), optional `layers/`, `icons/`, and `preview.png`.
- Pros: Lossless (PNGs), viewable in image viewers, single-file packaging, easy to extend, straightforward to write/read in Java (`java.util.zip`), simple manifest evolution.
- Cons: Two-file semantics (manifest + assets) inside a container; slight overhead compared to a single PNG, but negligible.

2) Single PNG with embedded data ([Pico‑8 style](Pico8-Reference.md))
- Encode palette and per-pixel indices into the PNG image pixels or store project JSON in text chunks (iTXt/zTXt).
- Pros: Single image file that’s viewable and contains all data; users can see pixels directly.
- Cons: More brittle tooling, requires careful encoding/decoding and chunk handling; editing outside tool risks breaking encoded data. Harder to change schema later.

3) APNG / multi-frame PNG
- Pros: Built-in frames as a single image; previewable and lossless when using APNG.
- Cons: Limited metadata support for palette/layers/undo; not as widely supported as standard PNG in some tooling.

4) JSON/YAML with embedded binary (base64) or compressed RLE arrays
- Pros: Human-readable manifest and easy to diff; storing compressed binary blobs keeps sizes reasonable.
- Cons: Bigger, more awkward to inspect visually; base64 blobs are not directly viewable; more parsing overhead.

5) Custom binary format
- Pros: Compact and fast.
- Cons: Low interoperability, more development effort, brittle unless well versioned.

Recommendation
- Use Option 1: a ZIP-based container (`.ptz` or `.ptproj`) with:
  - `manifest.json` (formatVersion, canvas size, palette array, frames array, layer metadata, timestamps)
  - `frames/frame_###.png` (lossless PNGs; initially RGBA PNGs; later optionally paletted PNGs)
  - `preview.png` (optional) and `icons/` for tool icons exported from descriptors
  - `metadata.json` (optional extended metadata)
- Rationale: balances lossless storage, previewability, extensibility, and ease of implementation in Processing/Java.

Implementation notes
- Start with RGBA PNGs for frames (Processing can save these easily); add paletted/indexed PNG export later when required.
- Use `manifest.json` schema with `formatVersion` so we can evolve the format.
- Optionally include checksums (SHA256) in the manifest for integrity verification.
- Use `java.util.zip` for read/write in Processing sketches.

Consequences
- Simple to implement and inspect; projects are single-file archives usable across platforms and tools.
- Developers and artists can open frames in normal image viewers.

Future work
- Consider paletted PNG export for compact storage and exact palette preservation.
- Consider embedding lightweight diffs or undo metadata in `history/` if a compact undo format is desired.
- Optionally add support for single-PNG container as an export target for distribution (advanced feature).
