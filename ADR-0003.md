# ADR-0003: Zoom / Pan / State / Tool Responsibility Patterns

Date: 2026-02-04
Status: Accepted

Context
-------
The pixelTool sketch supports multiple interactive tools operating on a logical pixel canvas. Zoom and pan transform how the canvas is presented and how screen coordinates map to logical pixels. Historically zoom/pan state and behavior were scattered across globals and multiple files, leading to duplication and bugs during refactor.

Decision
--------
1. State ownership: The `StateManager` is the canonical store for application UI state related to transforms and input-mode flags. Specifically it holds:
   - `zoomScale` (float)
   - `zoomOffsetX`, `zoomOffsetY` (floats)
   - `minZoom`, `maxZoom` (floats)
   - `panning` (boolean) — whether a pan interaction is currently active
   - `panSticky` (boolean) — whether sticky pan (toggled via 'h') is active

2. Behavior ownership: Tools are responsible for behavior and math related to a feature. They expose imperative entrypoints (mouse handlers, keyboard entrypoints, and helper methods) that compute new state and then update the `StateManager`. Examples:
   - `ZoomTool.zoomBy(factor, screenX, screenY)` implements focal-point zoom math and calls `state.setZoomState(...)`.
   - `PanTool` activates sticky panning on `onActivate()` and clears it on `onDeactivate()`; the global input handlers use `state.isPanning()` to perform the actual offset updates.
   - `ColorTool.swapColors()` exposes a small API to switch `fgColor`/`bgColor`; key handlers delegate to the tool when appropriate.

3. Input routing and delegation:
   - Global key/mouse handlers are thin: they convert screen -> logical coordinates (via `screenToCanvas`) and then dispatch to the active tool when appropriate.
   - Keyboard shortcuts delegate to tools for behaviorful operations (e.g., `+`/`-` delegate to `ZoomTool.zoomBy`).
   - Mouse wheel delegates to `ZoomTool.zoomBy(mouseX, mouseY)`.
   - Space (momentary pan) sets `state.setPanning(true)` while held; `h` activates the `PanTool` so its lifecycle handles sticky pan.

4. Toolbar behavior:
   - The `Toolbar` may have no active tool by default (activeIndex = -1).
   - Selecting a tool calls `onDeactivate()` on the previous tool and `onActivate()` on the new tool. Tool lifecycle methods manage transient modes (e.g., `PanTool` toggles sticky pan on activate).
   - `Toolbar.setActive()` clears `panSticky` when a non-pan tool is selected.

Rationale
---------
- Centralizing state in `StateManager` removes duplication and makes it easy to reason about the single source of truth for transforms and interaction modes.
- Placing behavior in tools keeps mathematical logic and UX decisions co-located with the tool they implement, enabling easier unitization and future extraction.
- Thin global handlers and clear lifecycle hooks (`onActivate`/`onDeactivate`) keep the coupling low and make it straightforward to introduce new modes (e.g., touch gestures) later.

Consequences
------------
- Positive:
  - Easier to refactor and reason about pan/zoom behavior.
  - Tools become self-contained and testable units for their interactions.
- Tradeoffs / Negative:
  - Slight indirection: callers must find the appropriate tool instance to invoke certain behavior (e.g., `toolbar.getToolByNameInstance("Zoom")`). This is acceptable for the small codebase.

Implementation Notes
--------------------
- `StateManager` exposes getters/setters: `getZoomScale()`, `getZoomOffsetX/Y()`, `setZoomState(scale,x,y)`, `isPanning()`, `setPanning(bool)`, `isPanSticky()`, `setPanSticky(bool)`, `getMinZoom()`, `getMaxZoom()`.
- `ZoomTool.zoomBy(factor, screenX, screenY)` implements the focal-point preservation math:
  1. Resolve `screenX,screenY` to the canvas center if outside the canvas area.
  2. Convert to logical point ux,uy = (screen - offset) / prevScale.
  3. Compute newScale = clamp(prevScale * factor, minZoom, maxZoom).
  4. Compute offset so that screen point maps to the same logical ux,uy under newScale: newOffset = screen - ux * newScale.
  5. Call `state.setZoomState(newScale, newOffsetX, newOffsetY)`.

Migration Notes
---------------
- Remove legacy globals (`canvasScale`, `canvasOffsetX`, `canvasOffsetY`, and similar) once all call sites use `StateManager`.
- Replace direct calls to mutate pan/zoom with tool APIs where appropriate (e.g., keyboard shortcuts should call `ZoomTool.zoomBy`).

Related Files
-------------
- `pixelTool.pde` — main wiring, tool registration and drawing loop.
- `state.pde` — `StateManager` implementation.
- `zoomTool.pde` — `ZoomTool` behavior and `zoomBy` implementation.
- `panTool.pde` — `PanTool` lifecycle that manages sticky panning.
- `keyPresses.pde` — keyboard shortcuts delegating to tools and `StateManager`.
- `toolbar.pde` — tool lifecycle and selection logic.

Future Work
-----------
- Add unit tests for `ZoomTool.zoomBy` math.
- Consider adding a central ToolRegistry to avoid string lookups in `toolbar.getToolByNameInstance`.

Approved-by: project maintainers

