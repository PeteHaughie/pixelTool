# ADR-0002: Handling per-pixel operations and PGraphics pixel-stride mismatches

Status: Accepted

Context
-------
- This Processing sketch is a pixel editor that performs many direct per-pixel
  operations (drawing pixels, committing strokes, flood-fill). The code uses
  offscreen buffers (`PGraphics`) for the canvas, overlays and previews.
- On some platforms/backends (notably GPU-backed renderers and high-DPI
  displays) a `PGraphics` may use an internal backing store where the
  `pixels[]` array length is not equal to `width * height`. Common causes:
  - `P2D`/OpenGL renderer using scaled internal textures for Retina / HiDPI
    displays.
  - Implementation-specific stride/pixel-density where `pixels.length` is
    `(width*height) * (pd*pd)`.
- The project observed a repeatable bug: flood-fill appeared to affect only
  the top portion of the canvas and successive fills halved the filled height
  (visual scaling by 2x on each fill). The bug traced to assumptions about
  1:1 mapping between logical coordinates and `PGraphics.pixels` layout.

Decision
--------
- Treat `PGraphics` as an implementation detail whose `pixels[]` layout may
  vary; do not rely on `buf.pixels.length == width*height` when performing
  logical per-pixel algorithms.
- Introduce a stable, logical pixel buffer for the canvas (an `int[]`) that
  always uses a 1:1 mapping with logical coordinates (index = y*w + x).
  Make this authoritative for per-pixel algorithms (strokes, fills, undo).
- Keep the `PGraphics` as the visible backing, but update it from the logical
  buffer when necessary (or draw to it with small rects inside a single
  beginDraw()/endDraw()). This avoids copying mismatched pixel arrays and
  avoids renderer-specific stride issues.
- Where possible, draw the visible canvas using a `PImage` snapshot of the
  buffer (`buf.get()`) to avoid cross-PGraphics draw/layout mismatches.
- Use `JAVA2D` for offscreen buffers when exact 1:1 pixel semantics are
  required and performance/acceleration is not (or until a GPU-friendly
  logical workflow is implemented). However this is a compatibility option
  rather than the primary fix.

Consequences
------------
- Per-pixel algorithms (flood-fill, stroke rasterization) operate on the
  logical pixel array and are independent of renderer backing, so they will
  behave correctly on Retina/HiDPI and P2D targets.
- Rendering code needs to keep `PGraphics` in sync with the logical buffer.
  This can be done by:
  - Writing per-pixel rectangles (`rect(x,y,1,1)`) to the `PGraphics`
    inside a single `beginDraw()`/`endDraw()` block, or
  - Creating a `PImage` from the logical buffer (via `createImage()` and
    `updatePixels()` / `arrayCopy`) and drawing that image.
- Performance: writing many rects to `PGraphics` is slower than a fast
  array-copy, but is robust and still acceptable for the small canvas sizes
  used by this proof-of-concept. If performance becomes an issue, a fast
  conversion path (pack logical pixels into a `PImage` and `image()` it)
  can be implemented.

Implementation notes (what I changed)
------------------------------------
- `CanvasBuffer` (canvas.pde):
  - Added `int[] logicalPixels` sized `w*h` and updated `setPixel()` to
    write both the logical array and the `PGraphics`.
  - Updated `drawTo()` to render a `PImage` snapshot (`buf.get()`) instead
    of drawing `PGraphics` directly.

- `StateManager` (state.pde):
  - Reworked `floodFill()` to operate on the `CanvasBuffer`'s logical pixel
    array rather than the `PGraphics.pixels` array.
  - Flood-fill now collects filled indices and commits them to the canvas
    in a single `beginDraw()`/`endDraw()` pass to keep the draw updates
    atomic and consistent.
  - Added diagnostics while investigating; final algorithm uses the
    logical pixels as the source-of-truth.

- `Preview` and `overlay` handling (preview.pde, pixelTool.pde):
  - Where necessary, `PGraphics` were created with `JAVA2D` during
    investigation; final approach does not rely on forcing a renderer, but
    the code retains the option.

Alternatives considered
-----------------------
- Force `pixelDensity(1)` globally or always use `JAVA2D` for all PGraphics.
  - Pros: simplifies assumptions about `pixels[]` layout.
  - Cons: defeats HiDPI support and sacrifices GPU acceleration; brittle
    if some parts of the app require `P2D` for effects.
- Always convert `PGraphics.get()` into a logical-sized `PImage` before
  processing (what we did earlier in the investigation). This works but
  can be less efficient and still requires careful `updatePixels()` and
  `image()` handling.

Recommended patterns going forward
---------------------------------
1. Treat logical pixel operations as operating on an explicit logical
   buffer. Expose accessors like `CanvasBuffer.getLogicalPixels()` and
   `CanvasBuffer.setPixel(x,y,col)` for all editing operations.
2. When updating the visible canvas, either:
   - Draw small rectangles into the `PGraphics` inside a single `beginDraw()`
     / `endDraw()` block (safest), or
   - Pack the logical pixels into a `PImage` and draw the image in one call
     (fast but requires careful `updatePixels()` usage).
3. Avoid relying on `buf.pixels` or `.loadPixels()` for per-pixel algorithms
   if the renderer may be `P2D` or you need HiDPI compatibility.
4. Document renderer choices: `P2D` is for GPU-accelerated drawing, `JAVA2D`
   for exact-per-pixel editing.

Manual test plan
----------------
- Run the sketch and draw lines at various positions across the canvas.
- Press `F` (flood-fill) at several positions (top, middle, bottom) and
  verify the filled area respects existing pixels and covers the entire
  expected region.
- Swap foreground/background repeatedly and repeat fills to ensure no
  progressive scaling behavior occurs.
- Use `d` key to dump `canvas_dump.png` and compare the saved image to the
  on-screen canvas.

Notes
-----
- The root cause was assumptions about a 1:1 mapping between logical
  coordinates and `PGraphics.pixels` layout which do not hold on accelerated
  backends or HiDPI displays. The adopted solution provides a robust,
  renderer-independent approach that keeps logical editing simple and
  reliable.

Files changed while investigating and implementing this ADR
-----------------------------------------------------------
- `canvas.pde` (added `logicalPixels`, synced writes, draw snapshot)
- `state.pde` (rewrote `floodFill` to use logical buffer)
- `preview.pde`, `pixelTool.pde` (temporary/optional JAVA2D use and snapshot
  drawing; careful handling retained)

Signed-off-by: GitHub Copilot (implementation assistant)
